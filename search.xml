<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>I learned something today: C++ (part II)</title>
      <link href="/2019/07/25/c-plus-plus-note-2/"/>
      <url>/2019/07/25/c-plus-plus-note-2/</url>
      <content type="html"><![CDATA[<h1 id="Move-semantics"><a href="#Move-semantics" class="headerlink" title="Move semantics"></a>Move semantics</h1><p>​    最近在读一本名叫“<em>C++ High Performance</em>”的书，觉得有一定帮助，学习了一点现代的C++，故记录下自己通俗的理解。</p><h2 id="Rule-of-three"><a href="#Rule-of-three" class="headerlink" title="Rule of three"></a>Rule of three</h2><p>​    前人的经验告诉我们，一个类应该负责好自己所拥有的资源的管理，当一个类被复制（copy），被赋值（assign）到其他类或是被析构（destruct）的时候，它应对所拥有的资源也应该做出相应的正确的操作。这一理念在实践中被提炼为 <em>the rule of three</em>。“<em>three</em>” 代表一个类的 copy-constructor，copy-assignment 和 destructor 三个成员函数，如果你自定义了这三个函数中的其中一个，那么你很有可能还需明确定义其他两个函数。如下面Buffer类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// other functions...</span></span><br><span class="line">    <span class="comment">// Copy constructor  </span></span><br><span class="line">    Buffer(<span class="keyword">const</span> Buffer&amp; other) : size_&#123;other.size_&#125; &#123;    </span><br><span class="line">        ptr_ = <span class="keyword">new</span> <span class="keyword">float</span>[size_];    </span><br><span class="line">        <span class="built_in">std</span>::copy(other.ptr_, other.ptr_ + size_, ptr_);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Copy assignment</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Buffer&amp; other) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = <span class="keyword">new</span> <span class="keyword">float</span>[other.size_];</span><br><span class="line">        <span class="keyword">delete</span> [] ptr_;</span><br><span class="line">        ptr_ = tmp;</span><br><span class="line">        size_ = other.size_;    </span><br><span class="line">        <span class="built_in">std</span>::copy(other.ptr_, other.ptr_ + size_, ptr_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// Destructor  </span></span><br><span class="line">    ~Buffer() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] ptr_; </span><br><span class="line">        ptr_ = <span class="literal">nullptr</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:  <span class="keyword">size_t</span> size_&#123;<span class="number">0</span>&#125;;  <span class="keyword">float</span>* ptr_&#123;<span class="literal">nullptr</span>&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然而，这样有很多复制的操作，复制是有代价的，有时我们并不想要复制，传入的对象也不需要被保留，比如当我们把一个函数的返回值直接作为函数参数时。使用指针可以避免一些复制，但管理指针也并不那么方便：只能靠程序员自己。</p><h2 id="Rule-of-five-and-Move-semantics"><a href="#Rule-of-five-and-Move-semantics" class="headerlink" title="Rule of five and Move semantics"></a>Rule of five and Move semantics</h2><p>​    于是，在<em>the rule of three</em> 的基础上，有了 <em>the rule of five</em> 。为了解决复制带来的问题，我们定义两个全新的函数：move constructor 和move assignment operator 。从名字就可以猜到，这两个函数不复制，而是直接移动资源。一个类定义了自己的move constructor后，就可以实现move semantics。</p><p>​    下面举一个利用move semantics带来好处的例子：假设我们要把若干个前面的buffer类，放入<code>std::vector</code>里。当<code>std::vector</code>容量不够的时候，必须重新分配更多的内存，然后利用拷贝构造函数，把原来内存里的旧对象一个个复制到新内存中，然后再摧毁旧的对象。但是如果我们的buffer类定义了move constructor ，<code>std::vector</code>就可以直接把旧对象移过来。</p><p>​    那么事不宜迟，我们马上为buffer类加上move constructor 和move assignment operator ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Buffer(Buffer&amp;&amp; other) <span class="keyword">noexcept</span>  <span class="comment">//不使用noexcept将不便于STL使用move semantics</span></span><br><span class="line">    : ptr_&#123;other.ptr_&#125;, size_&#123;other.size_&#125; &#123;    </span><br><span class="line">        other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">        other.size_ = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">auto</span>&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; other) <span class="keyword">noexcept</span> &#123; </span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    size_ = other.size_;</span><br><span class="line">    other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    other.size_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到，我们把拷贝构造函数里的 <code>Buffer&amp;</code>改成了 <code>Buffer&amp;&amp;</code> ：有或是没有<code>&amp;&amp;</code>，就代表了我们是想要“move”还是“copy”。<code>&amp;&amp;</code>这个东西用C++术语来说，叫做<em>Rvalue Reference Declarator</em> ，表示这两个函数接收所谓的<em>r-value</em> ，当我们调用构造函数，传入的是<em>r-value</em>时，我们便运用的是“move”而不是“copy”。</p><p>​    那么什么是<em>r-value</em>？粗要的理解，<em>r-value</em>就是我们没给名字的对象。例如我们直接用函数的返回值做参数。同时也可以用 <code>std::move()</code> 得到<em>r-value</em>。但是注意，int，float等等原始的数据类型只会被拷贝。见如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"223"</span>;</span><br><span class="line"><span class="keyword">auto</span> y = move(x); <span class="comment">//没有效果，相当于 auto y = x；</span></span><br><span class="line"><span class="keyword">auto</span> z = move(s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//‘s’ is moved</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">223</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>I learned something today: C++ (part I)</title>
      <link href="/2019/07/21/c-plus-plus-note-1/"/>
      <url>/2019/07/21/c-plus-plus-note-1/</url>
      <content type="html"><![CDATA[<h1 id="Learn-Modern-C"><a href="#Learn-Modern-C" class="headerlink" title="Learn . Modern C++"></a>Learn . Modern C++</h1><p>​        最近在读一本名叫“<em>C++ High Performance</em>”的书，觉得有一定帮助，学习了一点现代的C++，故记录。</p><h2 id="Automatic-type-deduction-the-auto-keyword"><a href="#Automatic-type-deduction-the-auto-keyword" class="headerlink" title="Automatic type deduction: the auto keyword"></a>Automatic type deduction: the <em>auto</em> keyword</h2><h3 id="In-function-signatures"><a href="#In-function-signatures" class="headerlink" title="In  function signatures"></a>In  function signatures</h3><p>​    可以使用<code>auto</code>来标识函数返回值类型，例如以下表达式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return type: value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span><span class="comment">// 无聊的传统用法</span></span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span><span class="keyword">const</span><span class="comment">// 炫酷的船新用法，结果与下面两个表达式相同</span></span></span><br><span class="line">auto func() const -&gt; int// 另一炫酷的船新用法, 当声明和定义不在一个文件时适用</span><br><span class="line"><span class="comment">// Return type: reference</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span>&amp; <span class="title">cref</span><span class="params">()</span> <span class="keyword">const</span><span class="comment">// 结果与下面两个表达式相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">cref</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line">auto cref() -&gt; const int&amp;</span><br></pre></td></tr></table></figure><h3 id="In-variables"><a href="#In-variables" class="headerlink" title="In variables"></a>In variables</h3><p>​    在声明变量时使用<code>auto</code>，会令人产生一种正在使用某些动态类型语言的错觉，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">auto</span> x = Foo&#123;&#125;; </span><br><span class="line"><span class="keyword">auto</span> y = func(); </span><br><span class="line"><span class="keyword">auto</span> z = <span class="built_in">std</span>::mutex&#123;&#125;;</span><br></pre></td></tr></table></figure><p>​    使用了<code>auto</code>关键字后，我们可以不用担心自己是否使用了正确的变量类型，但我们仍需决定，我们想要的是reference 还是copy，以及变量是只读还是需要修改，如果是只读，最好显式的表明，例如使用 <code>const auto&amp;</code>。</p><h2 id="The-lambda-function"><a href="#The-lambda-function" class="headerlink" title="The lambda function"></a>The lambda function</h2><h3 id="Basic-syntax"><a href="#Basic-syntax" class="headerlink" title="Basic syntax"></a>Basic syntax</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;;<span class="comment">// the lambda function, 接收a，b两个参数比较大小</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;compare(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//output 1</span></span><br><span class="line"><span class="keyword">auto</span> nums = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">sort(nums.begin(), nums.end(), compare);</span><br><span class="line">    <span class="comment">//Or: sort(nums.begin(), nums.end(), [](int a,int b)&#123;return a&lt;b;&#125;);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="The-capture-block"><a href="#The-capture-block" class="headerlink" title="The capture block"></a>The capture block</h3><p>​    Lambda function 的小括号里是参数，花括号里是函数语句，这些和一般的函数是一样的，多出来的方括号为capture block</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">count_above</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vals, <span class="keyword">int</span> th)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">auto</span> is_above = [th](<span class="keyword">int</span> v) &#123; <span class="keyword">return</span> v &gt; th; &#125;;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::count_if(vals.begin(), vals.end(), is_above); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码中，参数th被capture block “捕获”，复制进了lambda function 内，从而可以灵活的改变is_above函数要比较的值。当然capture block 中也可以放reference。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> func = [t](<span class="keyword">int</span> b)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b+t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line">++t;</span><br><span class="line">func(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure><p>​    上面的lambda 与下面定义的这个类相似。但是每一个Lambda 的类型都是不同的，即使他们一毛一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Func</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Func(<span class="keyword">int</span> t):t&#123;t&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">//with only one member function</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> b)</span><span class="keyword">const</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; b+t &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> t;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> func = Func(t);</span><br><span class="line">++t;</span><br><span class="line">func(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//output: 3</span></span><br></pre></td></tr></table></figure><p>​    我们也可以在capture block里的初始化变量，可以看做在类里初始化成员变量一般。但是我们不能在普通的lambda 里更改capture block 所capture 的变量，原因可以在上面看到：对应类的唯一一个成员函数是用const标记的。要使得我们能够更改capture的变量，需要加上<code>mutable</code>这一modifier，或是一开始就传递引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [&amp;t](<span class="keyword">int</span> b)&#123;</span><br><span class="line">    t++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b+t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">auto</span> func = [t](<span class="keyword">int</span> b) <span class="keyword">mutable</span> &#123;</span><br><span class="line">    t++; <span class="comment">//没有mutable会报错</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b+t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    通过使用<code>[=]</code> or <code>[&amp;]</code>，我们可以无脑的capture当前可用的所有变量，<code>[=]</code>意味着“captures all by value”，而<code>[&amp;]</code>意味着“captures all by reference”。当然，我们并不是真正的把所有变量都被复制到了lambda内，只有我们实际用了的变量会真正地被复制。我们也可以指定个别变量的捕捉方式，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c; </span><br><span class="line"><span class="keyword">auto</span> func = [=, &amp;c]()&#123;&#125;; <span class="comment">//Capture c by reference，and a,b by value</span></span><br><span class="line"><span class="keyword">auto</span> func = [&amp;, c]()&#123;&#125;;<span class="comment">//Capture c by value，and a,b by reference</span></span><br></pre></td></tr></table></figure><h3 id="Lambdas-and-std-function"><a href="#Lambdas-and-std-function" class="headerlink" title="Lambdas and std::function"></a>Lambdas and std::function</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt; return_type ( parameter0, parameter1...) &gt; </span><br><span class="line"><span class="comment">// a std::function returning a bool and having two int as parameters:</span></span><br><span class="line"><span class="keyword">auto</span> func = <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure><p>​    如果我们的lambda有和某个<code>std::function</code>相同的返回类型且接收相同的参数类型，那么该lambda就可以装入该<code>std::function</code>中，以下为实际使用例子，实现了类似<em>策略模式</em>的感觉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Killer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Killer(function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; a): action_&#123;a&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">takeAction</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">action_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt; action_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> killer1 = Killer([]() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Slash!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line"><span class="keyword">auto</span> killer2 = Killer([]() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Shoot!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line"><span class="keyword">auto</span> killer3 = Killer([]() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hug!"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;);</span><br><span class="line"><span class="keyword">auto</span> killer_squad = <span class="built_in">vector</span>&lt;Killer&gt;&#123;killer1, killer2, killer3&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; killer : killer_squad)</span><br><span class="line">killer.takeAction();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output：</span></span><br><span class="line"><span class="comment">Slash!</span></span><br><span class="line"><span class="comment">Shoot!</span></span><br><span class="line"><span class="comment">Hug!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​    然而，相比直接用lambda，使用<code>std::function</code>付出的代价更大， 无论是从时间上还是空间上考虑。</p>]]></content>
      
      
        <tags>
            
            <tag> Coding </tag>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Are video games an art form</title>
      <link href="/2019/04/22/are-video-games-an-art-form/"/>
      <url>/2019/04/22/are-video-games-an-art-form/</url>
      <content type="html"><![CDATA[<h1 id="电子游戏是艺术吗"><a href="#电子游戏是艺术吗" class="headerlink" title="电子游戏是艺术吗"></a>电子游戏是艺术吗</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    从1962年的 <em>Spacewar!</em> 到如今的各类3A电子游戏大作，电子游戏已经由当初计算机实验室里的屏幕检测和性能测试程序，变成了整个世界娱乐产业里的统治性项目：电子游戏改变了人们的娱乐方式，游戏产业比电影，音乐以及其他传统娱乐项目要赚得多得多。但是对于电子游戏是不是一种艺术形式这个话题，一直存在一定的争议。我这次将针对这个具有争议的话题提出一些看法，以及探讨一下电子游戏与艺术的关系。</p><h2 id="电子游戏的独特性"><a href="#电子游戏的独特性" class="headerlink" title="电子游戏的独特性"></a>电子游戏的独特性</h2><p>​    电子游戏的最具有特色的一点，就是电子游戏是及其具有交互性的。所有其他的艺术作品，或是娱乐方式：比如电影或绘画之类，都不会因为观众或欣赏者的反应而改变，这些作品是不会与人直接互动的，我们通常是观察者。而电子游戏，无论是第一个获得商业成功走进平常人家里的只有白色像素的<em>Pong</em>，还是如今的3D的，真人影像的，以及VR的电子游戏，都有一个共同的特征，那就是互动性或者说交互性。人们可以直接的控制<em>Pong</em>里的球拍，直接的控制水管工马里奥的动作。即使是最简单的游戏，因为有了交互，每个人眼前的游戏都会是不同的。同时也因为其交互性，电子游戏更容易获得大众的喜爱。</p><p>​    电子游戏的另外一个特点，就是电子游戏具有很强的综合性。先如今，一个优秀电子游戏的制作，不仅需要计算机专业人员，还需要画家，3d建模师，设计师，还需要演员来配音和进行动作捕捉，如今的3A游戏还需要导演和编剧等。电子游戏因为其综合性强，游戏内容也很灵活，因此需要各个行业的人才。</p><h2 id="电子游戏与艺术的相似性"><a href="#电子游戏与艺术的相似性" class="headerlink" title="电子游戏与艺术的相似性"></a>电子游戏与艺术的相似性</h2><p>​    艺术是什么？我们很难明确的表述，一方面是因为艺术的范围是如此的广，内容是如此的多；另一方面，艺术家自己也在不停的修改艺术的定义，挑战人们对艺术的观念。从历史上来看，艺术一开始是用来教化大众的。古希腊的戏剧，就是民众教育的重要一环，这不仅仅是为了消遣，更是一种义务。此后，艺术是宗教的工具，中世纪的西方，似乎一切的，高尚的艺术都是围绕基督教的；建筑，绘画或音乐的主题似乎都是围绕宗教的。在文艺复兴和宗教改革后，艺术的目的显得多样起来。有时候是为了政治宣传，比如 <a href="https://en.wikipedia.org/wiki/Jacques-Louis_David" target="_blank" rel="noopener">Jacques-Louis David</a> 的<em>Napoleon Crossing the Alps</em>就是给拿破仑做的政治宣传；但是更多的，是为了表达作者自己的情感，以及时代的现状。从艺术的这些目的来看，游戏和艺术是相似的。不仅相似，而且在传递情感和描述的方面，电子游戏这一形式是对于传统的艺术形式有优势的：例如在传递情感的方面，由于电子游戏具有很强大的交互性，玩家作为普通人可以更加容易的带入电子游戏的场景，更加容易的感受到创作者想要表达的情感。这种沉浸和带入，降低了欣赏的门槛，简化了传统艺术作品表达情感的过程：我们不用抽象成一个冷静的第三者来欣赏。电子游戏提供的视角是其他艺术方式提供不了的：你就是作品的一部分。西班牙宫廷画家 <a href="https://en.wikipedia.org/wiki/Diego_Velázquez" target="_blank" rel="noopener">Diego Velázquez</a> 在他的<em>Las Meninas</em> (创作于1656年，既下图) 创造性地使用了非常巧妙的视角，意图让看画的人成为画的一部分，而类似的感觉在现代的电子游戏中却可以轻易的做到。</p><img src="/2019/04/22/are-video-games-an-art-form/Las_Meninas.jpg" title="Las Meninas"><p>​    现实中已经有很多具有非凡意义的电子游戏，它们就像艺术提供给人们提供享受，或是给人以启发和灵感。比如 Valve 开发的传送门系列游戏，就可以让人体验到日常生活中体验不到的空间感。还有利用了视错觉原理而开发的游戏：<em>Monument Valley</em>，这样的空间，在现实中是不可能存在的，而通过电子游戏，我们不仅可以看到它，还可以与这个不可能的空间互动，只有电子游戏能够做到这一点。还有Galactic Café 所开发的 <em><a href="https://store.steampowered.com/app/221910/The_Stanley_Parable/" target="_blank" rel="noopener">The Stanley Parable</a></em> 则对传统游戏进行了解构，游戏充满了“虚假”的选择，作者试图告诉我们在游戏中无论你做出怎样的选择，都是被设计好的，而玩家在游戏中虽然有自我的选择，却只能扮演游戏里的主人公；作者试着提问玩家：当你在玩游戏时是你在控制游戏，还是游戏在控制你？2016年发行的 <a href="https://store.steampowered.com/app/419460/That_Dragon_Cancer/" target="_blank" rel="noopener"><em>That Dragon, Cancer</em></a> 则是开发者们以其中一人的患癌症而死的孩子的生前的生活为基础，让玩家也可以感受到他们家人与癌症抗争时的希望与绝望，以及父母对孩子深沉的爱，“玩”过这款电子游戏后，玩家似乎就已经经历了父母与孩子的各种绝望的时刻，以及面对绝症的释然。这样的感染力和体验，正是传统艺术所珍视的宝贵特质。</p><p>​    同时电子游戏也可以成为传统艺术形式的一种延申或是扩展，因为电子游戏在表现形式上来看，是可以和传统的绘画，建筑，音乐等结合的，通过设计师，建模师的努力，建筑可以在电子游戏中以3D模型的形式出现，比如最近舆论讨论的巴黎圣母院，可以在 <em>Assassin’s Creed Unity</em> 中再现风采；而音乐除了作为配乐，也可以作为互动元素融入电子游戏中。</p><h2 id="电子游戏与传统艺术的差别"><a href="#电子游戏与传统艺术的差别" class="headerlink" title="电子游戏与传统艺术的差别"></a>电子游戏与传统艺术的差别</h2><p>​    在电子游戏中，有一种感受是其他艺术形式所不能传达的：骄傲感,或者是说成就感，这是电子游戏的特色。这是因为绝大多数的现存的游戏，都是以目标驱动的，或者说，是可以通关的，是有输和赢的概念的。而其余的艺术形式，无论是文学，绘画，还是电影，你可以并且只可以去感受和观察，你不能“通关”一个绘画，也不会有输和赢。其次，电子游戏是有规则的，电子游戏是电脑程序，所以是有序的，有规则限定的。我们可以以自己喜欢的方式来欣赏一段音乐，阅读一本小说，而在游戏中玩家注定是限制在开发者规则内的。这个问题在我前面提到的 <em>The Stanley Parable</em> 中就有提到。也就是只要你打开游戏，无论你自己觉得多自由，你在游戏里的行为都是被开发者所界定的。其实延申开来，这是一个经常讨论的哲学问题：人到底是有自由意志，还是由命运决定的。在电子游戏的例子下，开发者扮演了虚拟世界“造物主”的角色，因此可以看到自己虚拟世界里的一切都是预先决定的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    游戏是不是一种艺术形式存在争议，其实是因为人们在对艺术的理解上存在区别。目前我们不可否认的是，游戏是由艺术家参与的，含有甚至大量含有艺术元素的。现在的市面上的绝大多数电子游戏，由于作为一个商业的软件，更像是一种娱乐服务。然而少数的电子游戏，则完全可以得到艺术品的评价。总的来说，电子游戏与传统的艺术形式有着一定的相似性，很多艺术形式在它的早期，都是不被看作是一种艺术形式的，而是被看作一种媒体，既传达信息用的，从文学到绘画再到“motion picture”，都经历了类似的过程，文学初始就是传递信息用的，绘画是统治者给大众传递信息的等等。所以，也许电子游戏确实是一种艺术形式，只不过它还在其发展的早期，其艺术性没有完全体现而已。但随着社会的不断发展，电子游戏也会逐渐的成为一种广泛认可的艺术形式。</p>]]></content>
      
      
        <tags>
            
            <tag> Video game </tag>
            
            <tag> Art </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Beethoven&#39;s late period</title>
      <link href="/2018/04/07/Beethoven-s-late-period/"/>
      <url>/2018/04/07/Beethoven-s-late-period/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>贝多芬，<strong>Ludwig van Beethoven</strong>,  出生于<strong>德国</strong>波恩，是世界音乐史上最伟大的作曲家<del>之一</del>。下面的内容里我将以通俗易懂的方式介绍贝多芬的晚期，以贝多芬晚期的主要作品为中心。此文章讲的不少是Xiaopei的<strong>个人观点</strong>，目的在于帮助你了解这位具有无穷魅力的音乐大师。虽然在我的观念里，“欣赏”音乐不一定需要对于作者有了解（你只需要心，脑和耳就行了），但是了解作曲家，确实可以给你一个不同的欣赏角度。如果感觉内容“与你存在隔阂”，建议在各种音乐播放器中，用给出的作品英文名搜索并播放，不要让它成为一个死板的名字，事实上，我在平时也不会去刻意记住某一篇乐曲的名字。<strong>音乐从来都不是死的，音乐是行走于时间的艺术，只有当时间停止，音乐才会死亡</strong>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="贝多芬的三个时期"><a href="#贝多芬的三个时期" class="headerlink" title="贝多芬的三个时期"></a>贝多芬的三个时期</h3><p>学者们习惯于把贝多芬的作品按风格和年代分为三个时期。对于我们普通人来说，也是可以感觉到这三个时期贝多芬音乐风格的变化。贝多芬的<strong>第一时期</strong>到大概1802年，此时贝多芬32岁，他已经开始有耳聋了。贝多芬吸收了那个时代的音乐语言后，发出了自己的声音，在此期间创作了著名的第8号钢琴奏鸣曲Piano Sonata No. 8 (<a href="http://music.163.com/#/song?id=1068241" target="_blank" rel="noopener">第一乐章</a>，<a href="http://music.163.com/#/song?id=1068244" target="_blank" rel="noopener">第二乐章</a>, <a href="http://music.163.com/#/song?id=1068247" target="_blank" rel="noopener">第三乐章</a>)，也就是俗称的悲怆奏鸣曲，还有两首交响曲等等。<strong>第二时期</strong>到1815年，代表作就更多了，不再多说，因为主要内容是讲最后一个时期。</p><h3 id="三个主要作品"><a href="#三个主要作品" class="headerlink" title="三个主要作品"></a>三个主要作品</h3><p>我在这里主要介绍贝多芬的这三个作品：</p><ul><li>贝多芬个人的深刻的信仰表白：    庄严弥撒曲  <a href="http://music.163.com/#/album?id=34886326" target="_blank" rel="noopener">Missa solemnis</a></li><li>贝多芬最伟大的交响曲<del>之一</del>：        第九交响曲  <a href="http://music.163.com/#/album?id=35278440" target="_blank" rel="noopener"> Symphony No. 9 in D minor</a></li><li>令人摸不着头脑的，超前的：    大赋格曲  <a href="http://music.163.com/#/song?id=22318533" target="_blank" rel="noopener">Grosse Fuge</a></li></ul><h4 id="Missa-solemnis"><a href="#Missa-solemnis" class="headerlink" title="Missa solemnis"></a>Missa solemnis</h4><p>贝多芬自己把这首<a href="https://baike.baidu.com/item/弥撒/1317" target="_blank" rel="noopener">弥撒</a>曲当作他最伟大的作品。正如前面所说它是个人的深刻的信仰表白。是为了庆祝某人荣升大主教而写作的。</p><blockquote><p>这部作品所包含的远不止是音乐和礼仪的象征，其中许多知识是知识贫乏的听众不能理解的。</p></blockquote><p>的确，对于国内的不信教的我们来说，要了解背后的东西确实太过繁复，它的每一个乐章都是常规弥撒，也就是作为宗教仪式，的一部分。尽管如此，这仍是了解贝多芬的不错切入点——他的信仰，在贝多芬不幸，贫穷且孤独的一生中，显然对上帝的信仰扮演了很重要的位置。他也曾写到：</p><blockquote><p>There is no loftier mission than to approach the Divinity nearer than other men, and to disseminate the divine rays among mankind.</p></blockquote><h4 id="Symphony-No-9"><a href="#Symphony-No-9" class="headerlink" title="Symphony No. 9"></a>Symphony No. 9</h4><p><strong>第九交响曲</strong>首演与1824年5月7日。在首演那天，交响曲演奏完毕，不少人热泪盈眶，人们热烈的欢呼鼓掌。贝多芬却没有转身向听众致谢，因为他听不见。这时一位独唱演员“拽了拽他的袖子，让他注意人们在拍手和挥舞帽子和手帕”贝多芬这才转过来。<br>音乐会取得了巨大的成功，但是贝多芬的收入却非常的少，贝多芬责备管理此事的朋友欺骗了他，但这又能怎么样。于是，两个月后，第九交响曲再次上演，但只卖了一半的票而亏损了。贝多芬最伟大的作品却把他自己陷入如此尴尬的局面，真是令人感到愤慨和惋惜。</p><p>第九交响曲的亮点无疑在于最后的合唱。合唱团开口前应该干什么，站着等着？站哪里呢？难道等要唱才上去？（答案应该是等着）合唱团和交响乐团的指挥呢？贝多芬聋了怎么指挥？但是我们能肯定的是贝多芬解决了这些问题，至少首演是成功的，每个人都被这一组合所震撼了。</p><p>在我看来，第九交响曲也是贝多芬一生的写照，如果说以前的作曲家灌输在作品里的是情绪，贝多芬灌输的，则是思想。关于快乐与痛苦，理想与现实，贝多芬如果做一个如同前人一样的作曲家，专注为教会工作，为贵族工作（当然贝多芬也为他们写了曲子，毕竟为了生计）。他不太可能会有如此艰难的生活。我从贝多芬中听到的，是他告诉我们：<strong>不要屈服</strong>，追逐自己的热情，过得惨又如何，你能惨过我吗！在痛苦中，贝多芬却在讴歌欢乐。这是”用痛苦换来的欢乐“。</p><h4 id="Grosse-Fuge"><a href="#Grosse-Fuge" class="headerlink" title="Grosse Fuge"></a>Grosse Fuge</h4><blockquote><p>an absolutely contemporary piece of music that will be contemporary forever<br>这绝对是首当代音乐，而且永远都会是当代</p><footer><strong>Igor Stravinsky</strong></footer></blockquote><p>以难懂著称的大赋格曲！我不好意思说什么，无论是演奏的技术难度还是风格，都在贝多芬的晚期作品中脱颖而出。早期人们并不接受这一奇怪的风格，但现在大赋格被认为是贝多芬最出色的作品之一。贝多芬就像从古典时期直接跳到了现代时期一样。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只有很少的同代人理解贝多芬的晚期作品，这些作品都很有个性。影响后人的，不是贝多芬的古典气息，而是他骨子里的革命气息。从此以后，音乐是自我表达的一种基本方式，一代一代的浪漫主义作曲家都为贝多芬而着迷。贝多芬唤醒了后人心中的野兽。最后，再引用一段话：</p><blockquote><p>不管是不是浪漫主义，反正贝多芬是音乐史上的一种巨大的破坏力量。在他之后，事情不再是原样的了，他打开了通往新世界的大门。</p><footer><strong>Donald Jay Grout&Claude V. Palisca</strong><cite>A History of Western Music</cite></footer></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Welcome</title>
      <link href="/2018/04/01/Welcome/"/>
      <url>/2018/04/01/Welcome/</url>
      <content type="html"><![CDATA[<p>  欢迎。欢迎来到SWCN。你已选择，或被推荐来到Xiaopei管理的所谓 “博客”。<br>  我对SWCN寄予厚望，并且会不时的更新新的有趣的内容，Github也为本网站的中的一切提供了周到的考虑。你们能够来访问这个“博客”，我感到非常荣幸，我在此衷心地感谢你，不管你是Xiaopei的好朋友，还只是匆匆过客。<br>  欢迎来到SWCN。这里很安全。</p><blockquote><p>Welcome. </p><footer><strong>Wallace Breen</strong><cite><a href="http://half-life.wikia.com/wiki/Breencast#Dr._Breen_welcoming_Citizens_to_City_17" target="_blank" rel="noopener">Welcome to City 17</a></cite></footer></blockquote>]]></content>
      
      
    </entry>
    
  
  
</search>
